<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用 Nginx 和 Gunicorn 部署 Django 博客</title>
      <link href="/2019/02/26/shi-yong-nginx-he-gunicorn-bu-shu-django-bo-ke/"/>
      <url>/2019/02/26/shi-yong-nginx-he-gunicorn-bu-shu-django-bo-ke/</url>
      
        <content type="html"><![CDATA[<p>针对很多朋友反映按照教程的做法始终只能看到 Nginx 欢迎页面的问题，Tian Pengfei sanyuwen 给出了很好的建议。如果你也被类似问题困扰，不妨尝试一下这个建议。</p><blockquote><p>这个问题也困扰了很久，最终发现是sites-enabled文件夹里默认的default文件中的配置覆盖了自己写的配置，导致配置不生效，把default文件删掉就可以正常被nginx代理过去了，亲测有效</p></blockquote><p>我们博客的基础功能已经开发的基本差不多了，虽然还有很多地方可以完善，但我们还是希望早点把博客部署到服务器上，让他人可以通过外网访问。至于有待完善的地方，可以等部署完后一点点地迭代和改进。现在就让我们来把博客部署到服务器上吧！</p><p><strong>注意：本文的每一个步骤都在真实环境下验证无误。除非你知道自己在做什么，否则我们建议每一步均严格按照教程的指导来，这样能保证你顺利完成部署。</strong></p><h1 id="部署前准备"><a href="#部署前准备" class="headerlink" title="部署前准备"></a><strong>部署前准备</strong></h1><p>我们将使用比较流行的 Nginx + Gunicorn 的方式将 Django 开发的博客部署到自己的服务器，让别人能够通过域名访问你的博客。至于 Nginx、Gunicorn 是什么暂时放到一边，读完本教程后你就会知道它们的作用和使用方法了。</p><p>为了部署我们的博客，需要满足以下两个条件：</p><ol><li>有一台可以通过外网访问的服务器。</li><li>有一个域名。<br>如果你已经满足以上条件，可以直接跳到后面的搭建服务器部分。这里简单介绍一下我目前所知的以最低成本满足以上两个条件的方式。</li></ol><h2 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a><strong>购买服务器</strong></h2><p>如果你是学生，推荐购买阿里云服务器，学生优惠价是 9.9 元/月，而且服务器性能比较高。购买地址：阿里云服务器学生专区。具体的购买步骤这里就不赘述了，根据网站的指引相信你肯定能够购买成功。只是注意一点的是在选服务器类型的时候选择公共镜像，这样系统比较纯净。操作系统建议选 ubuntu 14.04 64位，这是本教程使用的服务器环境。</p><p>如果你不是学生，推荐购买搬瓦工 vps。目前最便宜的是 19.9美元/年，缺点是服务器性能没有阿里云高，但优点是顺带可以用它来搭梯子，从此访问 google、youtube 不是梦（基于 shadowsocks 只需简单几步就可以搭建起自己的梯子服务器）。同样购买的过程就不赘述了，搬瓦工 vps 中文网 有超级详细的指引。只是注意安装操作系统时建议选 ubuntu 14.04 64位，这是本教程使用的服务器环境。</p><p>如果你不差那点钱，随意选择一个云服务器提供商购买一个云服务器即可。</p><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a><strong>购买域名</strong></h2><p>域名服务商很多，我这里使用的是 阿里云域名注册系统。域名是网站的门牌，如果打算长期运营这个网站建议多考虑考虑，选一个适当的域名。如果只是为了测试，随便注册一个域名即可，一些非常见后缀的域名非常便宜，一般 10元/年就能搞定。但注意一点根据工信部规定，以下后缀的域名需要实名认证后才能使用：</p><p>.cn/.com/.net/.top/.xyz/.vip/.club/.ren/.wang/.shop/.xin/.中国/.信息/.公司/.网络/.广东/.佛山</p><p>如果你购买的是上述后缀的域名，意味着需要提交个人的身份资料实名认证后才能正常使用，这通常需要花费几天的时间。所以如果只为了测试和学习部署的话，最好避开上述后缀的域名。</p><h2 id="搭建服务器"><a href="#搭建服务器" class="headerlink" title="搭建服务器"></a><strong>搭建服务器</strong></h2><p>本教程使用的本地环境为 Windows 10，服务器环境为 ubuntu 14.04（64 位）。如果你的环境和我的有所差异导致一些命令无法执行，将这些命令转换为你所在环境的命令执行即可。</p><p><strong>远程登录到服务器</strong></p><p>服务器通常位于云端，需要使用远程登录工具登录后才能对服务器进行操作。我使用的是 Xshell，Windows 下百度 Xshell 下载安装即可，软件对学校和个人用户是免费的。</p><p>如何远程登录到服务器这里就不赘述了，相信你参考网上的一些教程肯定能够顺利登录。假如你和我一样使用 Xshell 的话，这里有一篇很详细的教程可以参考：教你怎么使用xshell远程连接linux服务器。</p><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a><strong>安装软件</strong></h2><p>顺利连接到远程服务器了。如果是一台全新服务器的话，通常我们是以 root 用户登录的。在 root 下部署代码不安全，最好是建一个新用户（如果你已经以非 root 用户登录的话可以跳过这一步）。下面的一些列命令将创建一个拥有超级权限的新用户：</p><pre><code># 在 root 用户下运行这条命令创建一个新用户，yangxg 是用户名# 因为我叫杨学光，所以我取的用户名是 yangxg# 选择一个你喜欢的用户名，不一定非得和我的相同root@localhost:~# useradd -m -s /bin/bash yangxg# 把新创建的用户加入超级权限组root@localhost:~# usermod -a -G sudo yangxg# 为新用户设置密码# 注意在输密码的时候不会有字符显示，不要以为键盘坏了，正常输入即可root@localhost:~# passwd yangxg# 切换到创建的新用户root@localhost:~# su - yangxg# 切换成功，@符号前面已经是新用户名而不是 root 了yangxg@localhost:~$</code></pre><p>新用户创建并切换成功了。如果是新服务器的话，最好先更新一下系统，避免因为版本太旧而给后面安装软件带来麻烦。运行下面的两条命令：</p><pre><code>yangxg@localhost:~$ sudo apt-get updateyangxg@localhost:~$ sudo apt-get upgrade</code></pre><p>接下来就可以安装必要的软件了，这里我们需要用到的软件有 Nginx、Pytohn3、Git、pip 和 virtualenv。</p><pre><code>yangxg@localhost:~$ sudo apt-get install nginxyangxg@localhost:~$ sudo apt-get install git python3 python3-pipyangxg@localhost:~$ sudo pip3 install virtualenv</code></pre><h2 id="解析域名到服务器的-IP-地址"><a href="#解析域名到服务器的-IP-地址" class="headerlink" title="解析域名到服务器的 IP 地址"></a><strong>解析域名到服务器的 IP 地址</strong></h2><p>将域名和服务器的 IP 地址绑定后，用户就可以通过在浏览器输入域名来访问服务器了。</p><p>各大域名服务商都提供了域名解析服务，但其配置界面各有差异，请依据其指引完成域名解析。下面是我使用的阿里云域名解析页面。</p><p><img src="https://i.imgur.com/LNioqy0.png" alt=""></p><h2 id="启动-Nginx-服务"><a href="#启动-Nginx-服务" class="headerlink" title="启动 Nginx 服务"></a><strong>启动 Nginx 服务</strong></h2><p>Nginx 是用来处理静态文件请求的。比如当我们访问一个博客文章详情页面时，服务器会接收到下面两种请求：</p><ul><li>显示文章的详情信息，这些信息通常保存在数据库里，因此需要调用数据库获取数据。</li><li>图片、css、js 等存在服务器某个文件夹下的静态文件。</li></ul><p>对于前一种请求，博客文章的数据需要借助 Django 从数据库中获取，Nginx 处理不了，它就会把这个请求转发给 Django，让 Django 去处理。而对于后一种静态文件的请求，只需要去这些静态文件所在的文件夹获取，Nginx 就会代为处理，不再麻烦 Django。</p><p>用 Django 去获取静态文件是很耗时的，但 Nginx 可以很高效地处理，这就是我们要使用 Nginx 的原因（当然其功能远不止这些）。</p><p>通过前面的步骤我们已经安装了 Nginx，并且已经把域名和服务器 IP 绑定了。运行下面的命令启动 Nginx 服务：</p><pre><code>yangxg@localhost:~$ sudo service nginx start</code></pre><p>在浏览器输入域名，看到如下页面说明 Nginx 启动成功了。</p><p><img src="https://i.imgur.com/fFjzjkp.png" alt=""></p><h1 id="部署代码"><a href="#部署代码" class="headerlink" title="部署代码"></a><strong>部署代码</strong></h1><h2 id="部署前的项目配置"><a href="#部署前的项目配置" class="headerlink" title="部署前的项目配置"></a><strong>部署前的项目配置</strong></h2><p>Django 项目中会有一些 CSS、JavaScript 等静态文件，为了能够方便地让 Nginx 处理这些静态文件的请求，我们把项目中的全部静态文件收集到一个统一的目录下，这个目录通常位于 Django 项目的根目录，并且命名为 static。为了完成这些任务，需要在项目的配置文件里做一些必要的配置：</p><pre><code>blogproject/settings.py# 其他配置...STATIC_URL = &#39;/static/&#39;# 加入下面的配置STATIC_ROOT = os.path.join(BASE_DIR, &#39;static&#39;)</code></pre><p>STATIC_ROOT 指明了静态文件的收集目录，即项目根目录（BASE_DIR）下的 static 文件夹。</p><p>为了安全起见，在生产环境下需要关闭 DEBUG 选项以及设置允许访问的域名。打开 settings.py 文件，找到 DEBUG 和 ALLOWED_HOSTS 这两个选项，将它们设置成如下的值：</p><pre><code>blogproject/settings.pyDEBUG = FalseALLOWED_HOSTS = [&#39;127.0.0.1&#39;, &#39;localhost &#39;, &#39;.zmrenwu.com&#39;]</code></pre><p>ALLOWED_HOSTS 是允许访问的域名列表，127.0.0.1 和 localhost 是本地访问的域名，.zmrenwu.com 是访问服务器的域名（换成你自己的域名）。域名前加一个点表示允许访问该域名下的子域名，比如 <a href="http://www.zmrenwu.com、test.zmrenwu.com" target="_blank" rel="noopener">www.zmrenwu.com、test.zmrenwu.com</a> 等二级域名同样允许访问。如果不加前面的点则只允许访问 zmrenwu.com。</p><p>项目还会依赖一些第三方 Python 库，为了方便在服务器上一次性安装，我们将全部依赖写入一个叫 requirements.txt 的文本文件中。激活本地的虚拟环境（如果你使用了虚拟环境的话），并进入项目的根目录，运行 pip freeze &gt; requirements.txt 命令：</p><pre><code>(blogproject_env) C:\Users\yangxg\Workspace\blogproject&gt;pip freeze &gt; requirements.txt</code></pre><p>这时项目根目录下会生成了一个 requirements.txt 的文本文件，其内容记录了项目的全部依赖。</p><h2 id="将代码上传到-GitHub"><a href="#将代码上传到-GitHub" class="headerlink" title="将代码上传到 GitHub"></a><strong>将代码上传到 GitHub</strong></h2><p>将代码上传到 GitHub 等代码托管平台，这样我们就可以方便地把代码拉取到服务器了。Git 和 GitHub 的使用相信你已经很熟悉了，这里就不赘述过程。如果不知道如何使用地话可以自行百度相关教程。</p><p>注意数据库文件不要上传！</p><h2 id="设置服务器目录结构"><a href="#设置服务器目录结构" class="headerlink" title="设置服务器目录结构"></a><strong>设置服务器目录结构</strong></h2><p>接下来需要把代码上传到服务器了。我服务器上存放代码的目录结构一般是这样的：</p><pre><code>/home/yangxg/    sites/       demo.zmrenwu.com/           env/           django-blog-tutorial/</code></pre><p>一台服务器可能部署多个网站，所有网站代码都放在 sites/ 目录下。demo.zmrenwu.com/ 这个文件夹以网站的域名命名，便于区分。env/ 是 python 虚拟环境目录。django-blog-tutorial/ 是 Django 博客项目目录。</p><p>因此先来创建这个目录结构，注意目录名替换为你自己的域名，以后涉及到 demo.zmrenwu.com 的地方通常都要替换你自己的域名，后面就不再一一指出了，运行下面的命令，</p><pre><code>yangxg@localhost:~$ mkdir -p ~/sites/demo.zmrenwu.com</code></pre><p>这里 ~ 代表当前用户的 home 目录，即 /home/yangxg/。</p><p>接下来创建虚拟环境，先进入到 demo.zmrenwu.com 目录下，然后运行 virtualenv 命令创建虚拟环境：</p><pre><code>yangxg@localhost:~$ cd ~/sites/demo.zmrenwu.comyangxg@localhost:~/sites/demo.zmrenwu.com$ virtualenv --python=python3 env</code></pre><p>注意这里使用 –python=python3 来指定克隆 Python3 的环境。因为 ubuntu 系统默认安装了 Python2，如果不特别指定的话 Virtualenv 默认克隆的是 Python2 的环境。</p><p>检查一下虚拟环境是否创建成功，运行 ls 命令列出当前目录下的文件和文件夹，看到 env 这个文件夹说明虚拟环境创建成功。</p><pre><code>yangxg@localhost:~/sites/demo.zmrenwu.com$ lsenv</code></pre><p>接着再从代码仓库把项目代码拉取过来，把 git clone 后的地址换成你自己的 GitHub 仓库地址！</p><pre><code>yangxg@localhost:~/sites/demo.zmrenwu.com$ git clone https://github.com/zmrenwu/django-blog-tutorial.git</code></pre><p>运行 ls 命令检查一下是否拉取成功：</p><pre><code>yangxg@localhost:~/sites/demo.zmrenwu.com$ lsdjango-blog-tutorial  env</code></pre><p>多了 django-blog-tutorial 文件夹（文件夹名称由你的 GitHub 仓库名决定），说明拉取成功了。</p><h2 id="安装项目依赖"><a href="#安装项目依赖" class="headerlink" title="安装项目依赖"></a><strong>安装项目依赖</strong></h2><p>激活虚拟环境，再进入到项目根目录，即 requirements.txt 所在的目录，安装项目的全部依赖：</p><pre><code>yangxg@localhost:~/sites/demo.zmrenwu.com$ source env/bin/activate(env) yangxg@localhost:~/sites/demo.zmrenwu.com$ cd django-blog-tutorial/(env) yangxg@localhost:~/sites/demo.zmrenwu.com/django-blog-tutorial$ pip install -r requirements.txt</code></pre><h2 id="收集静态文件"><a href="#收集静态文件" class="headerlink" title="收集静态文件"></a><strong>收集静态文件</strong></h2><p>虚拟环境下继续运行 python manage.py collectstatic 命令收集静态文件到 static 目录下：</p><pre><code>(env) yangxg@localhost:~/sites/demo.zmrenwu.com/django-blog-tutorial$ python manage.py collectstatic</code></pre><h2 id="生成数据库"><a href="#生成数据库" class="headerlink" title="生成数据库"></a><strong>生成数据库</strong></h2><p>虚拟环境下继续运行 python manage.py migrate 命令创建数据库文件：</p><pre><code>(env) yangxg@localhost:~/sites/demo.zmrenwu.com/django-blog-tutorial$ python manage.py migrate</code></pre><h2 id="创建超级用户"><a href="#创建超级用户" class="headerlink" title="创建超级用户"></a><strong>创建超级用户</strong></h2><p>虚拟环境下继续运行 python manage.py createsuperuser 命令创建一个超级用户，方便我们进入 Django 管理后台。这和本地开发时是一样的，具体请参照：在 Django Admin 后台文章。</p><pre><code>(env) yangxg@localhost:~/sites/demo.zmrenwu.com/django-blog-tutorial$ python manage.py createsuperuser</code></pre><h2 id="配置-Nginx"><a href="#配置-Nginx" class="headerlink" title="配置 Nginx"></a><strong>配置 Nginx</strong></h2><p>接下是配置 Nginx 来处理用户请求。</p><p>先在服务器的 /etc/nginx/sites-available/ 目录下新建一个配置文件，文件名我一般就设置为域名。写上下面的配置内容：</p><pre><code>/etc/nginx/sites-available/demo.zmrenwu.comserver {    charset utf-8;    listen 80;    server_name demo.zmrenwu.com; ①    location /static { ②        alias /home/yangxg/sites/demo.zmrenwu.com/django-blog-tutorial/static;     }    location / { ③        proxy_set_header Host $host;        proxy_pass http://unix:/tmp/demo.zmrenwu.com.socket;    }}</code></pre><p>① 服务的域名为 demo.zmrenwu.com。</p><p>② 所有URL 带有 /static 的请求均由 Nginx 处理，alias 指明了静态文件的存放目录。</p><p>③ 其它请求转发给 Django 处理。proxy_pass 后面使用了 unix 套接字，其作用是防止端口冲突，这里就不再详述。</p><p>至于怎么在服务器新建文件和写文件，请自行学习一点点 vi 编辑器的用法，这里也不一一讲解了。</p><p>我们在 /etc/nginx/sites-available/ 放置了配置文件，接下来需要创建一个符号链接，把这个配置文件加入到启用的网站列表中去，被启用网站的目录在 /etc/nginx/sites-enabled/，你可以理解为从 sites-available/ 目录下发送了一个配置文件的快捷方式到 sites-enabled/ 目录。具体命令如下：</p><pre><code>(env) yangxg@localhost:~/sites/demo.zmrenwu.com/django-blog-tutorial$ sudo ln -s /etc/nginx/sites-available/demo.zmrenwu.com /etc/nginx/sites-enabled/demo.zmrenwu.com</code></pre><h2 id="使用-Gunicorn"><a href="#使用-Gunicorn" class="headerlink" title="使用 Gunicorn"></a><strong>使用 Gunicorn</strong></h2><p>Gunicorn 一般用来管理多个进程，有进程挂了Gunicorn 可以把它拉起来，防止服务器长时间停止服务，还可以动态调整 worker 的数量，请求多的时候增加 worker 的数量，请求少的时候减少。</p><p>在虚拟环境下，安装 Gunicorn：</p><pre><code>(env) yangxg@localhost:~/sites/demo.zmrenwu.com/django-blog-tutorial$ pip install gunicorn</code></pre><p>用 Gunicorn 启动服务器进程：</p><pre><code>(env) yangxg@localhost:~/sites/demo.zmrenwu.com/django-blog-tutorial$ gunicorn --bind unix:/tmp/demo.zmrenwu.com.socket blogproject.wsgi:application</code></pre><p>浏览器输入域名，可以看到访问成功了！</p><h2 id="自动启动-Gunicorn"><a href="#自动启动-Gunicorn" class="headerlink" title="自动启动 Gunicorn"></a><strong>自动启动 Gunicorn</strong></h2><p>现在 Gunicorn 是我们手工启动的，万一哪天服务器崩溃重启了又得重新手工启动。为此我们写一个自动启动脚本，这样当服务器重新启动后，脚本会帮我们重启 Gunicorn。先按 Ctrl + c 停止刚才启动的服务器进程。</p><p>写一个启动脚本，这样当服务器重启后能自动引导 Gunicorn 的启动。脚本位于 /etc/init/ 目录下，且脚本文件名必须以 .conf 结尾：</p><pre><code>/etc/init/gunicorn-demo.zmrenwu.com.confstart on net-device-up ①stop on shutdownrespawn ②setuid yangxg ③chdir /home/yangxg/sites/demo.zmrenwu.com/django-blog-tutorial ④exec ../env/bin/gunicorn --bind unix:/tmp/demo.zmrenwu.com.socket blogproject.wsgi:application ⑤</code></pre><p>① start on net-device-up 确保只在服务器联网时才启动 Gunicorn。</p><p>② 如果进程崩溃了（比如服务器重启或者进程因为某些以外情况被 kill），respawn 将自动重启 Gunicorn。</p><p>③ setuid 确保以 yangxg 用户的身份（换成你自己的用户名）运行 Gunicorn 进程。</p><p>④ chdir 进入到指定目录，这里进入项目的根目录。</p><p>⑤ exec 执行进程，即开启服务器进程。</p><p>现在可以用 start 命令启动 Gunicorn 了：</p><pre><code>sudo start gunicorn-demo.zmrenwu.com</code></pre><p>以后如果更新了代码，只要运行下面的命令重启一下 Nginx 和 Gunicorn 就可以使新的代码生效了：</p><pre><code>sudo service nginx reloadsudo restart gunicorn-demo.zmrenwu.com</code></pre><h2 id="使用-CDN-加快-Bootstrap-和-jQuery-的加载速度"><a href="#使用-CDN-加快-Bootstrap-和-jQuery-的加载速度" class="headerlink" title="使用 CDN 加快 Bootstrap 和 jQuery 的加载速度"></a><strong>使用 CDN 加快 Bootstrap 和 jQuery 的加载速度</strong></h2><p>我们的项目使用了 Bootstrap 和 jQuery，这两个文件我们是从本地加载的。如果服务器性能比较差的话，加载需要耗费很长的时间，网站打开的速度就变得无法忍受。我们使用 CDN 来加快加载速度。具体来说，替换 base.html 的几个静态文件的加载标签：</p><pre><code>base.html- &lt;link rel=&quot;stylesheet&quot; href=&quot;{% static 'blog/css/bootstrap.min.css' %}&quot;&gt;- &lt;script src=&quot;{% static 'blog/js/jquery-2.1.3.min.js' %}&quot;&gt;&lt;/script&gt;- &lt;script src=&quot;{% static 'blog/js/bootstrap.min.js' %}&quot;&gt;&lt;/script&gt;+ &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;+ &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js&quot;&gt;&lt;/script&gt;+ &lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;</code></pre><p>这样网站访问的速度将大大提升！</p><h2 id="部署过程自动化"><a href="#部署过程自动化" class="headerlink" title="部署过程自动化"></a><strong>部署过程自动化</strong></h2><p>在整个部署过程中我们运行了十几条命令，手动输入了 N 个字符。如果每次更新代码都要远程连接到服务器执行这些命令的话将变得非常麻烦。接下来的教程我们将介绍使用 Fabric 自动化整个部署过程。写好部署脚本后，只需要执行一条命令，就可以非常方便地自动完成整个部署。</p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>互联网协议入门（二）</title>
      <link href="/2019/02/18/hu-lian-wang-xie-yi-ru-men-er/"/>
      <url>/2019/02/18/hu-lian-wang-xie-yi-ru-men-er/</url>
      
        <content type="html"><![CDATA[<p><a href="https://huangzhazha.github.io/2019/02/13/hu-lian-wang-xie-yi-ru-men-yi/">上一篇文章</a>分析了互联网的总体构思，从下至上，每一层协议的设计思想。</p><p>这是从设计者的角度看问题，今天我想切换到用户的角度，看看用户是如何从上至下，与这些协议互动的。</p><p>==============================================================</p><p>互联网协议入门（二）</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201206/bg2012061109.jpg" alt=""></p><p>（接上文）</p><p>七、一个小结</p><p>先对前面的内容，做一个小结。</p><p>我们已经知道，网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。数据包的结构，基本上是下面这样：</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052913.png" alt=""></p><p>发送这个包，需要知道两个地址：</p><ul><li>对方的MAC地址</li><li></li><li>对方的IP地址</li></ul><p>有了这两个地址，数据包才能准确送到接收者手中。但是，前面说过，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关（gateway）转发。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201206/bg2012061101.jpg" alt=""></p><p>上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是（后文介绍判断方法），于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。</p><p>1号电脑把数据包发到网关A，必须知道网关A的MAC地址。所以，数据包的目标地址，实际上分成两种情况：</p><table><thead><tr><th>场景</th><th>数据包地址</th></tr></thead><tbody><tr><td>同一个网络</td><td>对方的MAC地址，对方的IP地址</td></tr><tr><td>非同一个子网络</td><td>网关的MAC地址，对方的IP地址</td></tr></tbody></table><p>发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的MAC地址。接下来，我们就来看，实际使用中，这个过程是怎么完成的。</p><p>八、用户的上网设置</p><p>8.1 静态IP地址</p><p>你买了一台新电脑，插上网线，开机，这时电脑能够上网吗？</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201206/bg2012061110.jpg" alt=""></p><p>通常你必须做一些设置。有时，管理员（或者ISP）会告诉你下面四个参数，你把它们填入操作系统，计算机就能连上网了：</p><ul><li>本机的IP地址</li><li>子网掩码</li><li>网关的IP地址</li><li>DNS的IP地址</li></ul><p>下图是Windows系统的设置窗口。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201206/bg2012061111.png" alt=""></p><p>这四个参数缺一不可，后文会解释为什么需要知道它们才能上网。由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作”静态IP地址上网”。</p><p>但是，这样的设置很专业，普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用”动态IP地址上网”。</p><p>8.2 动态IP地址</p><p>所谓”动态IP地址”，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做DHCP协议。</p><p>这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做”DHCP服务器”。新的计算机加入网络，必须向”DHCP服务器”发送一个”DHCP请求”数据包，申请IP地址和相关的网络参数。</p><p>前面说过，如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？</p><p>DHCP协议做了一些巧妙的规定。</p><p>8.3 DHCP协议</p><p>首先，它是一种应用层协议，建立在UDP协议之上，所以整个数据包是这样的：</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201206/bg2012061102.png" alt=""></p><p>　　（1）最前面的”以太网标头”，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。</p><p>　　（2）后面的”IP标头”，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。</p><p>　　（3）最后的”UDP标头”，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。</p><p>这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。</p><p>接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。</p><p>新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。</p><p>8.4 上网设置：小结</p><p>这个部分，需要记住的就是一点：不管是”静态IP地址”还是”动态IP地址”，电脑上网的首要步骤，是确定四个参数。这四个值很重要，值得重复一遍：</p><ul><li>本机的IP地址</li><li>子网掩码</li><li>网关的IP地址</li><li>DNS的IP地址</li></ul><p>有了这几个数值，电脑就可以上网”冲浪”了。接下来，我们来看一个实例，当用户访问网页的时候，互联网协议是怎么运作的。</p><p>九、一个实例：访问网页</p><p>9.1 本机参数</p><p>我们假定，经过上一节的步骤，用户设置好了自己的网络参数：</p><ul><li>本机的IP地址：192.168.1.100</li><li>子网掩码：255.255.255.0</li><li>网关的IP地址：192.168.1.1</li><li>DNS的IP地址：8.8.8.8</li></ul><p>然后他打开浏览器，想要访问Google，在地址栏输入了网址：<a href="http://www.google.com。" target="_blank" rel="noopener">www.google.com。</a></p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201206/bg2012061103.png" alt=""></p><p>这意味着，浏览器要向Google发送一个网页请求的数据包。</p><p>9.2 DNS协议</p><p>我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址<a href="http://www.google.com，不知道它的IP地址。" target="_blank" rel="noopener">www.google.com，不知道它的IP地址。</a></p><p>DNS协议可以帮助我们，将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201206/bg2012061105.png" alt=""></p><p>然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。</p><p>9.3 子网掩码</p><p>接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。</p><p>已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。</p><p>因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。</p><p>9.4 应用层协议</p><p>浏览网页用的是HTTP协议，它的整个数据包构造是这样的：</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201206/bg2012061106.png" alt=""></p><p>HTTP部分的内容，类似于下面这样：</p><pre><code>GET / HTTP/1.1Host: www.google.comConnection: keep-aliveUser-Agent: Mozilla/5.0 (Windows NT 6.1) ......Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Encoding: gzip,deflate,sdchAccept-Language: zh-CN,zh;q=0.8Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3Cookie: ... ...</code></pre><p>我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。</p><p>9.5 TCP协议</p><p>TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。</p><p>TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。</p><p>9.6 IP协议</p><p>然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。</p><p>IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。</p><p>9.7 以太网协议</p><p>最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。</p><p>以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201206/bg2012061107.png" alt=""></p><p>9.8 服务器端响应</p><p>经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。</p><p>根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的”HTTP请求”，接着做出”HTTP响应”，再用TCP协议发回来。</p><p>本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201206/bg2012061104.jpg" alt=""></p><p>这个例子就到此为止，虽然经过了简化，但它大致上反映了互联网协议的整个通信过程。</p><p>（完）</p><p>转载自：阮一峰的网站<a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 理解计算机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>互联网协议入门（一）</title>
      <link href="/2019/02/13/hu-lian-wang-xie-yi-ru-men-yi/"/>
      <url>/2019/02/13/hu-lian-wang-xie-yi-ru-men-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-1-五层模型"><a href="#1-1-五层模型" class="headerlink" title="1.1 五层模型"></a>1.1 五层模型</h2><p>互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。</p><p>用户接触到的，只是最上面的一层，根本没有感觉到下面的层。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。</p><p>如何分层有不同的模型，有的模型分七层，有的分四层。我觉得，把互联网分成五层，比较容易解释。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052902.png" alt=""></p><p>如上图所示，最底下的一层叫做”实体层”（Physical Layer），最上面的一层叫做”应用层”（Application Layer），中间的三层（自下而上）分别是”链接层”（Link Layer）、”网络层”（Network Layer）和”传输层”（Transport Layer）。越下面的层，越靠近硬件；越上面的层，越靠近用户。</p><p>它们叫什么名字，其实并不重要。只需要知道，互联网分成若干层就可以了。</p><h2 id="1-2-层与协议"><a href="#1-2-层与协议" class="headerlink" title="1.2 层与协议"></a>1.2 层与协议</h2><p>每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。</p><p>大家都遵守的规则，就叫做”协议”（protocol）。</p><p>互联网的每一层，都定义了很多协议。这些协议的总称，就叫做”互联网协议”（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。</p><h1 id="二、实体层"><a href="#二、实体层" class="headerlink" title="二、实体层"></a>二、实体层</h1><p>我们从最底下的一层开始。</p><p>电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052903.png" alt=""></p><p>这就叫做”实体层”，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。</p><h1 id="三、链接层"><a href="#三、链接层" class="headerlink" title="三、链接层"></a>三、链接层</h1><h2 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h2><p>单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？</p><p>这就是”链接层”的功能，它在”实体层”的上方，确定了0和1的分组方式。</p><h2 id="3-2-以太网协议"><a href="#3-2-以太网协议" class="headerlink" title="3.2 以太网协议"></a>3.2 以太网协议</h2><p>早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做”以太网”（Ethernet）的协议，占据了主导地位。</p><p>以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052904.png" alt=""></p><p>“标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。</p><p>“标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p><h2 id="3-3-MAC地址"><a href="#3-3-MAC地址" class="headerlink" title="3.3 MAC地址"></a>3.3 MAC地址</h2><p>上面提到，以太网数据包的”标头”，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？</p><p>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052905.jpg" alt=""></p><p>每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052906.png" alt=""></p><p>前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p><h2 id="3-4-广播"><a href="#3-4-广播" class="headerlink" title="3.4 广播"></a>3.4 广播</h2><p>定义地址只是第一步，后面还有更多的步骤。</p><p>首先，一块网卡怎么会知道另一块网卡的MAC地址？</p><p>回答是有一种ARP协议，可以解决这个问题。这个留到后面介绍，这里只需要知道，以太网数据包必须知道接收方的MAC地址，然后才能发送。</p><p>其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？</p><p>回答是以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052907.png" alt=""></p><p>上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的”标头”，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。</p><p>有了数据包的定义、网卡的MAC地址、广播的发送方式，”链接层”就可以在多台计算机之间传送数据了。</p><h1 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h1><h2 id="4-1-网络层的由来"><a href="#4-1-网络层的由来" class="headerlink" title="4.1 网络层的由来"></a>4.1 网络层的由来</h2><p>以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。</p><p>但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。</p><p>互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052914.png" alt=""></p><p>因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。（”路由”的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。</p><p>这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。</p><p>于是，”网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。</p><p>网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</p><h2 id="4-2-IP协议"><a href="#4-2-IP协议" class="headerlink" title="4.2 IP协议"></a>4.2 IP协议</h2><p>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。</p><p>目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052908.png" alt=""></p><p>习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。</p><p>互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。</p><p>但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。</p><p>那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数”子网掩码”（subnet mask）。</p><p>所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p><p>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p><p>比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。</p><p>总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</p><h2 id="4-3-IP数据包"><a href="#4-3-IP数据包" class="headerlink" title="4.3 IP数据包"></a>4.3 IP数据包</h2><p>根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。</p><p>但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？</p><p>回答是不需要，我们可以把IP数据包直接放进以太网数据包的”数据”部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。</p><p>具体来说，IP数据包也分为”标头”和”数据”两个部分。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052909.png" alt=""></p><p>“标头”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052910.png" alt=""></p><p>IP数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的”数据”部分，最长为65,515字节。前面说过，以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p><h2 id="4-4-ARP协议"><a href="#4-4-ARP协议" class="headerlink" title="4.4 ARP协议"></a>4.4 ARP协议</h2><p>关于”网络层”，还有最后一点需要说明。</p><p>因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。</p><p>所以，我们需要一种机制，能够从IP地址得到MAC地址。</p><p>这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。</p><p>第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是的FF：FF：FF：FF：FF：FF表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。</p><p>总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。</p><h1 id="五、传输层"><a href="#五、传输层" class="headerlink" title="五、传输层"></a>五、传输层</h1><h2 id="5-1-传输层的由来"><a href="#5-1-传输层的由来" class="headerlink" title="5.1 传输层的由来"></a>5.1 传输层的由来</h2><p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。</p><p>接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？</p><p>也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p><p>“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p><p>“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。</p><h2 id="5-2-UDP协议"><a href="#5-2-UDP协议" class="headerlink" title="5.2 UDP协议"></a>5.2 UDP协议</h2><p>现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。</p><p>UDP数据包，也是由”标头”和”数据”两部分组成。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052911.png" alt=""></p><p>“标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的”数据”部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052912.png" alt=""></p><p>UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p><h2 id="5-3-TCP协议"><a href="#5-3-TCP协议" class="headerlink" title="5.3 TCP协议"></a>5.3 TCP协议</h2><p>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。</p><p>为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。</p><p>因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。</p><p>TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p><h1 id="六、应用层"><a href="#六、应用层" class="headerlink" title="六、应用层"></a>六、应用层</h1><p>应用程序收到”传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。</p><p>“应用层”的作用，就是规定应用程序的数据格式。</p><p>举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。</p><p>这是最高的一层，直接面对用户。它的数据就放在TCP数据包的”数据”部分。因此，现在的以太网的数据包就变成下面这样。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052913.png" alt=""></p><p>至此，整个互联网的五层结构，自下而上全部讲完了。这是从系统的角度，解释互联网是如何构成的。下一篇，我反过来，从用户的角度，自上而下看看这个结构是如何发挥作用，完成一次网络数据交换的。</p><p>（完）<br>转载自：阮一峰的网站<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 理解计算机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/02/13/hello-world/"/>
      <url>/2019/02/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
